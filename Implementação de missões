/* war_missoes.c
Implementação das missões estratégicas para um War estruturado.
Usa malloc, strcpy, ponteiros, modularização, srand/time e libera memória.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define MAX_NOME 30
#define MAX_COR 10
#define MAX_MISSAO_LEN 100

/* Estrutura do territorio */
typedef struct {
    char nome[MAX_NOME];
    char cor[MAX_COR]; /* cor/dono do territorio */
    int tropas;
} Territorio;

/* Estrutura de jogador */
typedef struct {
    char cor[MAX_COR];
    char *missao; /*armazenada dinamicamente*/
} Jogador;

/* --- Assinatura de funções --- */
void atribuirMissao(char* destino, char* missoes[], int totalMissoes);
int verificarMissao (const char* missao, territorio* mapa, int tamanho, const char* corJogador);
void exibirMissao(const char* missao); /*passada por valor (ponteiro para const) */
void atacar(Territorio* atacante, Territorio* defensor);
void exibir Mapa(Territorio* mapa, int tamanho);
void liberarMemoria(Territorio* mapa, int tamanho, Jogador* jogadores, int totalJogadores);

/* --- Implementações ---- */
/*Sorteia uma missao do vetor missoes e copia para destino (destino deve ser buffer alocado). */
void atribuirMissao(char* destino, char* missoes[], int totalMissoes) {
    ind idx = rand() % totalMissoes;
    strcpy(destino , missoes[idx]);
}

/* Exibe a missão - passagem por "valor" no sentindo de usar const char* (não altera). */
void exibirMissao(const char* missao){
    printf(" >>> Missao do jogador:  %s\n, missao");
}

/*Verifica se a missão foi cumprida.
A lógica procura palavras-chave na string da missão e aplica uma regra simples.
Recebe corJogador para saber "dono" dos territorios.
Retorna 1 se cumprida, 0 caso contrário.
 */
int verificarMissao(const char* missao, Territorio* mapa, int tamanho, const char* corJogador) {
    /*Contadores úteis*/
    int totalDoJogador = 0;
    int totalTropasAdversario =0;
    int maiorConsecutivos =0;
}

/*calcula contagens */
for (int i  = 0; i < tamanho; ++i) {
    if ( strcpm(mapa[i].cor, corJogador) == 0) {
        totalDoJogador++;
        atualConsecutivos++;
    } else {
        if (atualConsecutivos >maiorConsecutivos)
        maiorConsecutivos = atualConsecutivos;
        atualConsecutivos = 0;
        totalTropasAdversario += mapa[i].tropas;
    }
}
if (atualConsecutivos > maior Consecutivos) maiorConsecutivos = atualConsecutivos;

/* Regras simples baseadas em palavras-chaves contidas em missao*/
if (strstr(misao, "3 territorios consecutivos") != NULL) {
    return (maiorConsecutivos >= 3) ? 1 : 0;
    } else if (strstr(missao, "5 territorios") != NULL) {
        return (totalDOJogador >= 5) ? 1 : 0;
    } else if




