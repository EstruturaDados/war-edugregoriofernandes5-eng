/* war_missoes.c
Implementação das missões estratégicas para um War estruturado.
Usa malloc, strcpy, ponteiros, modularização, srand/time e libera memória.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define MAX_NOME 30
#define MAX_COR 10
#define MAX_MISSAO_LEN 100

/* Estrutura do territorio */
typedef struct {
    char nome[MAX_NOME];
    char cor[MAX_COR]; /* cor/dono do territorio */
    int tropas;
} Territorio;

/* Estrutura de jogador */
typedef struct {
    char cor[MAX_COR];
    char *missao; /*armazenada dinamicamente*/
} Jogador;

/* --- Assinatura de funções --- */
void atribuirMissao(char* destino, char* missoes[], int totalMissoes);
int verificarMissao (const char* missao, territorio* mapa, int tamanho, const char* corJogador);
void exibirMissao(const char* missao); /*passada por valor (ponteiro para const) */
void atacar(Territorio* atacante, Territorio* defensor);
void exibir Mapa(Territorio* mapa, int tamanho);
void liberarMemoria(Territorio* mapa, int tamanho, Jogador* jogadores, int totalJogadores);

/* --- Implementações ---- */
/*Sorteia uma missao do vetor missoes e copia para destino (destino deve ser buffer alocado). */
void atribuirMissao(char* destino, char* missoes[], int totalMissoes) {
    ind idx = rand() % totalMissoes;
    strcpy(destino , missoes[idx]);
}

/* Exibe a missão - passagem por "valor" no sentindo de usar const char* (não altera). */
void exibirMissao(const char* missao){
    printf(" >>> Missao do jogador:  %s\n, missao");
}

/*Verifica se a missão foi cumprida.
A lógica procura palavras-chave na string da missão e aplica uma regra simples.
Recebe corJogador para saber "dono" dos territorios.
Retorna 1 se cumprida, 0 caso contrário.
 */
int verificarMissao(const char* missao, Territorio* mapa, int tamanho, const char* corJogador) {
    /*Contadores úteis*/
    int totalDoJogador = 0;
    int totalTropasAdversario =0;
    int maiorConsecutivos =0;
}

/*calcula contagens */
for (int i  = 0; i < tamanho; ++i) {
    if ( strcpm(mapa[i].cor, corJogador) == 0) {
        totalDoJogador++;
        atualConsecutivos++;
    } else {
        if (atualConsecutivos >maiorConsecutivos)
        maiorConsecutivos = atualConsecutivos;
        atualConsecutivos = 0;
        totalTropasAdversario += mapa[i].tropas;
    }
}
if (atualConsecutivos > maior Consecutivos) maiorConsecutivos = atualConsecutivos;

/* Regras simples baseadas em palavras-chaves contidas em missao*/
if (strstr(missao, "3 territorios consecutivos") != NULL) {
    return (maiorConsecutivos >= 3) ? 1 : 0;
    } else if (strstr(missao, "5 territorios") != NULL) {
        return (totalDOJogador >= 5) ? 1 : 0;
    } else if (strstr(missao, "eliminar todas as tropas do adversario") != NULL) {
        /* adversário sem tropas no mapa */
        return (totalTropasAdversario == 0) ? 1 : 0;
    } else if (strstr(missao, "mais da metade") != NULL){
        return (totaldoJogador > (tamanho / 2)) ? 1 : 0;
    } else if (strstr(missao, "possuir 2 territorios") != NULL) {
        return (totalDoJogador >= 2) ? 1 : 0;
    }

    /* padrão: missão não reconhecida -> não cumprida */
    return 0;
}

/* Simula um ataque: rolagem entre 1 e 6 para atacante e defensor.
Se atacante vence, transfere metade das tropas do atacnte para defensor e atualiza a cor do defensor; caso contrário, atacante perde 1 tropa.
Valida ataques (não atacar território com mesma cor e precissa de perder tropas > 1)
*/
void atacar(Territorio* atacante, Territorio* defensor) {
    if (atacante == NULL || defensor == NULL) return;
    if (strcmp(atacante ->cor, defensor->cor) == 0){
        printf("Ataque inválido: mesmos donos (%s).\n, atacante->cor");
        return;
    }
    if (atacante ->tropas <= 1) {
        printf("Ataque inválido: atacante (%s) nao tem tropas suficientes.\n", atacante->nome);
        return;
    }
int rollA = (rand() % 6) + 1;
int rollD = (rand () % 6) + 1;

printf (" %s (cor %s, tropas %d) ataca %s (cor %s, tropas %d) -> dados: %d x %d\n",
    atacante ->nome, atacante ->cor, defensor ->tropas, rollA, rollD);





